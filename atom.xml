<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>squanche&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-05T03:44:07.432Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yzc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tree</title>
    <link href="http://yoursite.com/2020/06/05/tree/"/>
    <id>http://yoursite.com/2020/06/05/tree/</id>
    <published>2020-06-05T03:43:20.000Z</published>
    <updated>2020-06-05T03:44:07.432Z</updated>
    
    <content type="html"><![CDATA[<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><ol><li><p>如果某节点下方没有任何分叉的话，就是叶子节点。</p></li><li><p>从某节点出发，到叶子节点为止，最长简单路径上边的条数，称为该节点的<em>高度</em>。</p></li><li><p>从根节点出发，到某节点边的条数，称为该节点的深度</p></li></ol><h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5><ul><li><p>一个节点，即使只有根节点，也可以是一棵树。</p></li><li><p>其中任何一个节点与下面所有节点构成的树称为子。</p></li><li><p>根节点没有父节点，而叶子节点没有子节点子。</p></li><li><p>除根节点外，任何一个节点有且只有一个父节点</p></li><li><p>任何节点可以有0～n个子节点。</p></li></ul><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><h5 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h5><ol><li><p>树的左右高度差不能超过1</p></li><li><p>任何往下递归的左子树与右子树，必须符合第一条性质。</p></li><li><p>没有任何节点的空树或只有根节点的树也是平衡二叉树。  </p></li></ol><h5 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h5><p>平衡二叉树的左子树上所有节点的值都小于它，而它的右子树上所有节点的值都大于它。查找过程从树的根节点开始，沿着简单的判断向下走，小于节点值的往左边走，大于节点值的往右边走，直到找到目标数据或者到达叶子节点还未找到。</p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><h5 id="规则-2"><a href="#规则-2" class="headerlink" title="规则"></a>规则</h5><ol><li><p>节点只能是红色或黑色。</p></li><li><p>根节点必须是黑色。</p></li><li><p>所有 NIL 节点都是黑色的。即叶子节点下挂的两个虚节点。</p></li><li><p>一条路径上不能出现相连的两个红色节点。</p></li><li><p>在任何递归子树内，根节点到叶子节点的所有路径包含相同数目的黑色节点</p></li></ol><p>treeMap的是根据comparator或comparable来比较key的大小的。如果存在相等的key则暴力的替换掉。</p><p>所以treeMap的key必须实现comparable接口或者在treeMap的构造方法中提供comparator。同时treeMap的size是更具key的排序个数来统计的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h4&gt;&lt;h5 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hashMap</title>
    <link href="http://yoursite.com/2020/06/05/hashMap/"/>
    <id>http://yoursite.com/2020/06/05/hashMap/</id>
    <published>2020-06-05T03:42:49.000Z</published>
    <updated>2020-06-05T04:35:44.423Z</updated>
    
    <content type="html"><![CDATA[<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>Table数组的长度</td></tr><tr><td>size</td><td>成功通过 put 方法添加到HashMap 中的所有元素的个数</td></tr><tr><td>hashCode</td><td>object.hashCode()返回的值，尽可能离散均匀分布</td></tr><tr><td>Hash</td><td>Object.HashCode()与当前集合的 table.Length(进行位运算的结果，以确定哈希糟位置</td></tr></tbody></table><p>Jdk1.7扩容的时候resize()使用的是<strong><em>头插法</em></strong></p><h5 id="hashMap对象丢失的原因有以下几点"><a href="#hashMap对象丢失的原因有以下几点" class="headerlink" title="hashMap对象丢失的原因有以下几点"></a>hashMap对象丢失的原因有以下几点</h5><ol><li><p>并发赋值时被覆盖</p></li><li><p>己遍历区间新增元素会丢失。</p></li><li><p>“新表”被覆盖。</p></li><li><p>迁移丢失。在迁移过程中,有并发时,next 被提前 null</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap&quot; class=&quot;headerlink&quot; title=&quot;HashMap&quot;&gt;&lt;/a&gt;HashMap&lt;/h4&gt;&lt;h5 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="hashMap" scheme="http://yoursite.com/tags/hashMap/"/>
    
  </entry>
  
  <entry>
    <title>fast-fail</title>
    <link href="http://yoursite.com/2020/06/05/fast-fail/"/>
    <id>http://yoursite.com/2020/06/05/fast-fail/</id>
    <published>2020-06-05T02:42:36.000Z</published>
    <updated>2020-06-05T03:36:41.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="fast-fail"><a href="#fast-fail" class="headerlink" title="fast-fail"></a>fast-fail</h2><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ol><li><p>java.util.collection的集合都是fast-fail机制，java.util.concurrent下的则是fast-safe机制</p></li><li><p>collection触发fast-fail的场景就是多线程情况下，当一个线程A正在遍历集合，另外一个线程B修改、删除、或者变更该集合中的元素，导致正在遍历的线程A抛出ConcurrentModificationException异常。</p></li><li><p>A线程在创建便利起iterator是会copy一份modCount的值给内部的变量expectedModCount，每次hasnext的时候去比较modCount的值和expectedModCount的值是否一致，不一致说明modCount++了，因为其他线程对该集合元素进行了操作。当前线程遍历则会报错</p></li></ol><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li>使用iterator加锁遍历</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator= list.iterator(); </span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123; </span><br><span class="line">sychonized（对象）｛</span><br><span class="line">String item= iterator.next(); </span><br><span class="line"><span class="keyword">if</span> （删除元素的条件） &#123; </span><br><span class="line">iterator.remove();&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用COW</li></ol><p>使用java.util.concurrent并发包下的<strong><em>copyOnWrite</em></strong>的集合。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;fast-fail&quot;&gt;&lt;a href=&quot;#fast-fail&quot; class=&quot;headerlink&quot; title=&quot;fast-fail&quot;&gt;&lt;/a&gt;fast-fail&lt;/h2&gt;&lt;h4 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
  </entry>
  
</feed>
