<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />




  


  <link rel="alternate" href="/atom.xml" title="squanche's Blog" type="application/atom+xml" />






<meta name="description" content="选择比努力重要">
<meta property="og:type" content="website">
<meta property="og:title" content="squanche&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="squanche&#39;s Blog">
<meta property="og:description" content="选择比努力重要">
<meta property="article:author" content="squanche">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>squanche's Blog</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">squanche's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/21/ZooKeeper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="squanche">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="squanche's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/21/ZooKeeper/" itemprop="url">ZooKeeper</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-21T21:20:57+08:00">
                2020-07-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="ZooKeeper是什么"><a href="#ZooKeeper是什么" class="headerlink" title="ZooKeeper是什么"></a>ZooKeeper是什么</h4><p>Apache ZooKeeper是由集群（节点组）使用的一种服务，用于在自身之间协调，并通过稳健的同步技术维护共享数据。ZooKeeper本身是一个分布式应用程序，为写入分布式应用程序提供服务。</p>
<p>ZooKeeper提供的常见服务如下 :</p>
<ul>
<li><strong>命名服务</strong> - 按名称标识集群中的节点。它类似于DNS，但仅对于节点。</li>
<li><strong>配置管理</strong> - 加入节点的最近的和最新的系统配置信息。</li>
<li><strong>集群管理</strong> - 实时地在集群和节点状态中加入/离开节点。</li>
<li><strong>选举算法</strong> - 选举一个节点作为协调目的的leader。</li>
<li><strong>锁定和同步服务</strong> - 在修改数据的同时锁定数据。此机制可帮助你在连接其他分布式应用程序（如Apache HBase）时进行自动故障恢复。</li>
<li><strong>高度可靠的数据注册表</strong> - 即使在一个或几个节点关闭时也可以获得数据。</li>
</ul>
<p>分布式应用程序提供了很多好处，但它们也抛出了一些复杂和难以解决的挑战。ZooKeeper框架提供了一个完整的机制来克服所有的挑战。竞争条件和死锁使用<strong>故障安全同步方法</strong>进行处理。另一个主要缺点是数据的不一致性，ZooKeeper使用<strong>原子性</strong>解析。</p>
<p>以下是使用ZooKeeper的好处：</p>
<ul>
<li><strong>简单的分布式协调过程</strong></li>
<li><strong>同步</strong> - 服务器进程之间的相互排斥和协作。此过程有助于Apache HBase进行配置管理。</li>
<li><strong>有序的消息</strong></li>
<li><strong>序列化</strong> - 根据特定规则对数据进行编码。确保应用程序运行一致。这种方法可以在MapReduce中用来协调队列以执行运行的线程。</li>
<li><strong>可靠性</strong></li>
<li><strong>原子性</strong> - 数据转移完全成功或完全失败，但没有事务是部分的。</li>
</ul>
<h4 id="ZooKeeper的CAP定理"><a href="#ZooKeeper的CAP定理" class="headerlink" title="ZooKeeper的CAP定理"></a><strong>ZooKeeper的CAP定理</strong></h4><p>既一致性（Consistency）、分区容错性（Partition tolerance），因为集群少于半数的节点无法对外提供服务，因此不符合可用性（Availability）。</p>
<h4 id="ZooKeeper服务器的角色"><a href="#ZooKeeper服务器的角色" class="headerlink" title="ZooKeeper服务器的角色"></a>ZooKeeper服务器的角色</h4><table>
<thead>
<tr>
<th>角色</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Client（客户端）</td>
<td>客户端，我们的分布式应用集群中的一个节点，从服务器访问信息。对于特定的时间间隔，每个客户端向服务器发送消息以使服务器知道客户端是活跃的。类似地，当客户端连接时，服务器发送确认码。如果连接的服务器没有响应，客户端会自动将消息重定向到另一个服务器</td>
</tr>
<tr>
<td>Server（服务器）</td>
<td>服务器，我们的ZooKeeper总体中的一个节点，为客户端提供所有的服务。向客户端发送确认码以告知服务器是活跃的。</td>
</tr>
<tr>
<td>Ensemble</td>
<td>ZooKeeper服务器组。形成ensemble所需的<strong>最小节点数为3</strong>。</td>
</tr>
<tr>
<td>Follower</td>
<td>跟随leader指令的服务器节点。主要负责处理<br />1.处理客户端非事务性请求，转发事务请求给Leader服务器（事务请求都由Leader处理） <br/>2.参与事务请求Proposal的投票 <br/>3.参与Leader选举投票</td>
</tr>
<tr>
<td>Leader</td>
<td>服务器节点，如果任何连接的节点失败，则执行自动恢复。Leader在服务启动时被选举。主要负责处理<br />1.事务请求的唯一调度者和处理者，保证集群事务处理的顺序性。 <br/>2.集群内部各个服务器的调度者</td>
</tr>
<tr>
<td>Observer</td>
<td>观察zk集群的最新状态变化并将这些状态同步过来，对于非事务请求可以进行独立的处理，对于事务请求，则会转发给Leader服务器进行处理，<strong>Observer不会参与任何形式的投票</strong>，包括事务请求Proposal的投票和Leader选举的投票</td>
</tr>
</tbody>
</table>
<h4 id="ZooKeeper的元数据结构"><a href="#ZooKeeper的元数据结构" class="headerlink" title="ZooKeeper的元数据结构"></a>ZooKeeper的元数据结构</h4><p>类似于文件系统，每一个节点Znode。和文件系统一样，我们能够自由的增加、删除Znode，在一个Znode下增加、删除子Znode，唯一的不同在于Znode是可以存储数据的。</p>
<p><img src="../images/timg.jpg" alt=""></p>
<p><strong>为了保证事务的顺序一致性</strong>，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个<strong>64位的数字</strong>，<strong>它高32位是epoch</strong>用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。<strong>低32位用于递增计数</strong></p>
<p>ZooKeeper数据模型中的每个Znode都维护着一个 <strong>Stat</strong> 结构。一个stat仅提供一个Znode的<strong>元数据</strong>。它由版本号，操作控制列表(ACL)，<strong>时间戳</strong>和<strong>数据长度</strong>组成。</p>
<ul>
<li><strong>版本号</strong> 每个znode都有版本号，这意味着每当与znode相关联的数据发生变化时，其对应的版本号也会增加。当多个zookeeper客户端尝试在同一znode上执行操作时，版本号的使用就很重要。</li>
<li><strong>操作控制列表(ACL)</strong> - ACL基本上是访问znode的认证机制。它管理所有znode读取和写入操作。</li>
<li><strong>时间戳</strong> - 时间戳表示创建和修改znode所经过的时间。它通常以毫秒为单位。ZooKeeper从“事务ID”(zxid)标识znode的每个更改。<strong>Zxid</strong> 是唯一的，并且为每个事务保留时间，以便你可以轻松地确定从一个请求到另一个请求所经过的时间。</li>
<li><strong>数据长度</strong> - 存储在znode中的数据总量是数据长度。你最多可以存储1MB的数据。</li>
</ul>
<p>Stat包含的属性</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>czxid</td>
<td>创建Znode节点时的zxid</td>
</tr>
<tr>
<td>mzxid</td>
<td>节点被修改时最新的zxid</td>
</tr>
<tr>
<td>pzxid</td>
<td>最新修改的zxid</td>
</tr>
<tr>
<td>ctime</td>
<td>创建Znode节点的时间戳</td>
</tr>
<tr>
<td>mtime</td>
<td>修改Znode节点的时间戳</td>
</tr>
<tr>
<td>version</td>
<td>*当前节点版本号（可以理解为修改次数，每修改一次值+1）</td>
</tr>
<tr>
<td>cversion</td>
<td>子节点版本号（子节点修改次数，每修改一次值+1）</td>
</tr>
<tr>
<td>aversion</td>
<td>当前节点acl版本号（acl节点被修改次数，每修改一次值+1）</td>
</tr>
<tr>
<td>ephemeralOwner</td>
<td>临时节点标示，当前节点如果是临时节点，则存储的创建者的会话id（sessionId），如果不是，那么值=0</td>
</tr>
<tr>
<td>dataLength</td>
<td>当前节点数据长度</td>
</tr>
<tr>
<td>numChildren</td>
<td>当前节点子节点个数</td>
</tr>
</tbody>
</table>
<p>Znode的类型：</p>
<p>Znode被分为持久（persistent）节点，顺序（sequential）节点和临时（ephemeral）节点。</p>
<ul>
<li><strong>持久节点</strong> - 即使在创建该特定znode的客户端断开连接后，持久节点仍然存在。默认情况下，除非另有说明，否则所有znode都是持久的。</li>
<li><strong>临时节点</strong> - 客户端活跃时，临时节点就是有效的。当客户端与ZooKeeper集合断开连接时，临时节点会自动删除。因此，只有临时节点不允许有子节点。如果临时节点被删除，则下一个合适的节点将填充其位置。临时节点在leader选举中起着重要作用。</li>
<li><strong>顺序节点</strong> - 顺序节点可以是持久的或临时的。当一个新的znode被创建为一个顺序节点时，ZooKeeper通过将10位的序列号附加到原始名称来设置znode的路径。例如，如果将具有路径 <strong>/myapp</strong> 的znode创建为顺序节点，则ZooKeeper会将路径更改为 <strong>/myapp0000000001</strong> ，并将下一个序列号设置为0000000002。如果两个顺序节点是同时创建的，那么ZooKeeper不会对每个znode使用相同的数字。顺序节点在锁定和同步中起重要作用。</li>
</ul>
<h4 id="ZooKeeper的ZAB协议"><a href="#ZooKeeper的ZAB协议" class="headerlink" title="ZooKeeper的ZAB协议"></a>ZooKeeper的ZAB协议</h4><p>ZAB(Zookeeper Atomic Broadcast) 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。在 ZooKeeper 中，<strong>主要依赖 ZAB 协议来实现分布式数据一致性</strong>，基于该协议ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。</p>
<p>ZAB协议整体可划分为两个基本的模式：<strong>消息广播和崩溃恢复</strong></p>
<p>按协议原理可细分为四个阶段：<strong>选举（Leader Election）、发现（Discovery）、同步（Synchronization）和广播(Broadcast)</strong></p>
<p>按协议实现分为三个时期：<strong>选举（Fast Leader Election）、恢复(Recovery Phase)和广播(Broadcast Phase)</strong></p>
<ul>
<li>消息广播</li>
</ul>
<ol>
<li><p>leader 接收到消息请求后，将消息赋予一个全局唯一的64 位自增 id（叫:zxid），通过 zxid 的大小比较既可以实现因果有序这个特征。</p>
</li>
<li><p>leader 为每个 follower 准备了一个 FIFO 队列(通过 TCP协议来实现，以实现了全局有序这一个特点)将带有 zxid的消息作为一个提案(proposal)分发给所有的 follower。</p>
</li>
<li><p>当 follower 接收到 proposal，先把 proposal 写到磁盘，写入成功以后再向 leader 回复一个 ack。</p>
</li>
<li><p>当 leader 接收到合法数量(超过半数节点)的 ACK 后，leader 就会向这些 follower 发送 commit 命令，同时会在本地执行该消息。</p>
</li>
<li><p>当 follower 收到消息的 commit 命令以后会提交该消息。</p>
</li>
</ol>
<ul>
<li>崩溃恢复</li>
</ul>
<p>在正常运行情况下运行非常良好，但是一旦Leader服务器出现崩溃或者由于网络原因导致Leader服务器失去了与过半Follower的联系，那么就会进入崩溃恢复模式。在ZAB协议中，为了保证程序的正确运行，整个恢复过程结束后需要选举出一个新的Leader。服务器崩溃恢复主要包括Leader选举和数据恢复两部分</p>
<p><strong>FastLeaderElection原理</strong></p>
<p><strong>Zab的选票数据结构</strong></p>
<ul>
<li><p><strong>logicClock</strong> 表示这是该服务器发起的第多少轮投票，从1开始计数</p>
</li>
<li><p><strong>state</strong> 当前服务器的状态</p>
</li>
<li><p><strong>-self_id</strong> 当前服务器的<strong>唯一ID</strong></p>
</li>
<li><p><strong>self_zxid</strong> 当前服务器上所保存的数据的<strong>最大事务ID</strong>，从0开始计数</p>
</li>
<li><p><strong>vote_id</strong> 被推举的服务器的<strong>唯一ID</strong></p>
</li>
<li><p><strong>vote_zxid</strong> 被推举的服务器上所保存的数据的<strong>最大事务ID</strong>，从0开始计数</p>
</li>
</ul>
<p>ZooKeeper规定所有有效的投票都必须在同一轮次中。每个服务器在开始新一轮投票时，会先对自己维护的logicClock进行自增操作。</p>
<p>每个服务器在广播自己的选票前，会将自己的投票箱清空。该投票箱记录了所收到的选票。例：服务器2投票给服务器3，服务器3投票给服务器1，则服务器1的投票箱为(2, 3), (3, 1), (1, 1)。<strong>票箱中只会记录每一投票者的最后一票</strong>，如投票者更新自己的选票，则其它服务器收到该新选票后会在自己票箱中更新该服务器的选票。</p>
<p><strong>每个服务器最开始都是通过广播把票投给自己</strong>。服务器会尝试从其它服务器获取投票，并记入自己的投票箱内。如果无法获取任何外部投票，则会确认自己是否与集群中其它服务器保持着有效连接。如果是，则再次发送自己的投票；如果否，则马上与之建立连接。根据选票<strong>logicClock -&gt; vote_zxid -&gt; vote_id依次判断</strong></p>
<h4 id="基于ZooKeeper的选举流程"><a href="#基于ZooKeeper的选举流程" class="headerlink" title="基于ZooKeeper的选举流程"></a>基于ZooKeeper的选举流程</h4><p>让我们分析如何在ZooKeeper集合中选举leader节点。考虑一个集群中有N个节点。leader选举的过程如下：</p>
<ul>
<li>所有节点创建具有相同路径 /app/leader_election/guid_ 的顺序、临时节点。</li>
<li>ZooKeeper集合将附加10位序列号到路径，创建的znode将是 /app/leader_election/guid_0000000001，/app/leader_election/guid_0000000002等。</li>
<li>对于给定的实例，在znode中创建最小数字的节点成为leader，而所有其他节点是follower。</li>
<li>每个follower节点监视下一个具有最小数字的znode。例如，创建znode/app/leader_election/guid_0000000008的节点将监视znode/app/leader_election/guid_0000000007，创建znode/app/leader_election/guid_0000000007的节点将监视znode/app/leader_election/guid_0000000006。</li>
<li>如果leader关闭，则其相应的znode/app/leader_electionN会被删除。</li>
<li>下一个在线follower节点将通过监视器获得关于leader移除的通知。</li>
<li>下一个在线follower节点将检查是否存在其他具有最小数字的znode。如果没有，那么它将承担leader的角色。否则，它找到的创建具有最小数字的znode的节点将作为leader。</li>
<li>类似地，所有其他follower节点选举创建具有最小数字的znode的节点作为leader。</li>
</ul>
<p>leader选举是一个复杂的过程，但ZooKeeper服务使它非常简单。让我们在下一章中继续学习ZooKeeper安装，以用于开发目的。</p>
<h4 id="基于ZooKeeper实现分布式的公平可重入互斥锁"><a href="#基于ZooKeeper实现分布式的公平可重入互斥锁" class="headerlink" title="基于ZooKeeper实现分布式的公平可重入互斥锁"></a>基于ZooKeeper实现分布式的公平可重入互斥锁</h4><p>curator有提供</p>
<h4 id="ZooKeeper如何处理脑裂问题的"><a href="#ZooKeeper如何处理脑裂问题的" class="headerlink" title="ZooKeeper如何处理脑裂问题的"></a>ZooKeeper如何处理脑裂问题的</h4><p>要解决Split-Brain的问题</p>
<ul>
<li><p>Quorums（ˈkwôrəm 法定人数） ，比如3个节点的集群，Quorums = 2, 也就是说集群可以容忍1个节点失效，这时候还能选举出1个lead，集群还可用。比如4个节点的集群，它的Quorums = 3，Quorums要超过3，相当于集群的容忍度还是1，如果2个节点失效，那么整个集群还是无效的采用Redundant communications，冗余通信的方式，集群中采用多种通信方式，防止一种通信方式失效导致集群中的节点无法通信。</p>
</li>
<li><p>Fencing, 共享资源的方式，比如能看到共享资源就表示在集群中，能够获得共享资源的锁的就是Leader，看不到共享资源的，就不在集群中。</p>
</li>
</ul>
<p>  ZooKeeper默认采用了Quorums这种方式，即只有集群中超过半数节点投票才能选举出Leader。这样的方式可以确保leader的唯一性,要么选出唯一的一个leader,要么选举失败。在ZooKeeper中Quorums有2个作用：</p>
<p>  集群中最少的节点数用来选举Leader保证集群可用<br>  通知客户端数据已经安全保存前集群中最少数量的节点数已经保存了该数据。一旦这些节点保存了该数据，客户端将被通知已经安全保存了，可以继续其他任务。而集群中剩余的节点将会最终也保存了该数据</p>
<p>  假设某个leader假死，其余的followers选举出了一个新的leader。这时，旧的leader复活并且仍然认为自己是leader，这个时候它向其他followers发出写请求也是会被拒绝的。因为每当新leader产生时，会生成一个epoch，这个epoch是递增的，followers如果确认了新的leader存在，知道其epoch，就会拒绝epoch小于现任leader epoch的所有请求。那有没有follower不知道新的leader存在呢，有可能，但肯定不是大多数，否则新leader无法产生。Zookeeper的写也遵循quorum机制，因此，得不到大多数支持的写是无效的，旧leader即使各种认为自己是leader，依然没有什么作用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/20/MyBatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="squanche">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="squanche's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/20/MyBatis/" itemprop="url">MyBatis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-20T22:40:12+08:00">
                2020-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/05/List/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="squanche">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="squanche's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/05/List/" itemprop="url">List</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-05T16:33:27+08:00">
                2020-07-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p><a href="https://baike.baidu.com/item/list/4825101?fr=aladdin" target="_blank" rel="noopener">list</a> 数据接口是我们平常开发中必不可少的数据结构。在java中对他的描述如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An ordered collection The user of this interface has precise control over where in the list each element is inserted.  The user can access elements by their integer index (position in the list), and search for elements in the list</span><br></pre></td></tr></table></figure>
<p>我们从使用最频繁的ArrayList和LinkedList开始了解，首先我们看下它们的类结构图</p>
<p><img src="../images/1594035551652.jpg" alt="image-20200706193821788"></p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="基础属性"><a href="#基础属性" class="headerlink" title="基础属性"></a>基础属性</h4><p>先来看看它定义了哪些属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 默认初始化容量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化的值，空数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认容量的初始化值，与EMPTY_ELEMENTDATA区别开来的原因就是因为第一次添加元素的时候，下面会分析</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真正存放数据的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存放元素的数组的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 另外还有一个从父类继承过来的属性，用于实现fast-fail机制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>我们再来分析一下构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *带容量参数的初始化方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">//注意！！！当参数为0的时候这里使用的是EMPTY_ELEMENTDATA</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+                                  initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//无参的构造方法则是使用DEFAULTCAPACITY_EMPTY_ELEMENTDATA,这不是和EMPTY_ELEMENTDATA一样吗？是不是很奇怪为什么要这么分开？请看add方法</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*接收一个集合类型，转成数组，代码自解释。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>先从一个参数的方法来看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//下面这个判断就说明如果是使用无参构造器初始化的，DEFAULTCAPACITY_EMPTY_ELEMENTDATA，则会返回一个默认值DEFAULT_CAPACITY = 10和size+1两个值中较大的一个</span></span><br><span class="line">   <span class="comment">//如果是EMPTY_ELEMENTDATA的，则不处理默认值</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;<span class="comment">//在确定好容量后，这里modCount变更了</span></span><br><span class="line">      <span class="comment">//当容量大于数组长度时扩容</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">          <span class="comment">//扩容方法</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩容的方法相对简单</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">  <span class="comment">//扩容为原来的1.5倍</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">  <span class="comment">//直接把旧的数组复制到新数组上</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//我们在这里</span></span><br><span class="line">        <span class="comment">//然后就是直接赋值操作</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>另外指定位置的add方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//校验了下index的范围</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"><span class="comment">//见add方法说明</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  <span class="comment">//这边在调用native方法，把index位置以及之后的元素往后移动一个位置，此方法相当耗费资源</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    <span class="comment">//然后就是直接赋值操作</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从两种add方法可以得出结论：</p>
<p><strong><em>add的操作是o(1)，但是最坏的情况是o(n)因为数组必须调整大小并进行复制</em></strong></p>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//校验index是否溢出</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">  <span class="comment">//计算被移除元素的后续有多少个元素</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//把后续元素向前复制一个单位</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>可以看出，当不需要移动元素的情况下，remove的操作是o(1)，但是最坏的情况是o(n)，因为元素需要往前复制。</em></strong></p>
<p>在看另外一个remove方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">               <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">//跟remove(index)方法类似，就是没有返回值</span></span><br><span class="line">                   fastRemove(index);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">               <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                   fastRemove(index);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>可以看出，该方法的时间复杂度也是o(n)</em></strong></p>
<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>时间复杂度是o(1)</em></strong></p>
<h4 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">     rangeCheck(index);</span><br><span class="line">     E oldValue = elementData(index);</span><br><span class="line">     elementData[index] = element;</span><br><span class="line">     <span class="keyword">return</span> oldValue;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>时间复杂度是o(1)</em></strong></p>
<h3 id="linkedlist"><a href="#linkedlist" class="headerlink" title="linkedlist"></a>linkedlist</h3><h4 id="基础属性-1"><a href="#基础属性-1" class="headerlink" title="基础属性"></a>基础属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//首节点</span></span><br><span class="line"> <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"> <span class="comment">//尾巴节点</span></span><br><span class="line"> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/08/ReentrantLock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="squanche">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="squanche's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/08/ReentrantLock/" itemprop="url">ReentrantLock</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-08T10:20:13+08:00">
                2020-06-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前言：在看《码出高效》这边书，第七章节中提出了JUC中锁类，但是并未深入的对JUC里相关实现进行详细描述，所以我当场决定拜读下大名鼎鼎的AQS和其中的ReentranLock的实现。ps: Doug Lea 牛逼！</p>
<h4 id="走进ReetrantLock"><a href="#走进ReetrantLock" class="headerlink" title="走进ReetrantLock"></a>走进ReetrantLock</h4><h5 id="ReetrantLock是什么？"><a href="#ReetrantLock是什么？" class="headerlink" title="ReetrantLock是什么？"></a>ReetrantLock是什么？</h5><p>JDK官方给出的解释如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A reentrant mutual exclusion Lock with the same basic behavior and semantics as the implicit monitor lock accessed using <span class="keyword">synchronized</span> methods and statements, but with extended capabilities</span><br></pre></td></tr></table></figure>
<p>简单来说就是一个同步的互斥锁，功能和synchronized相似，但相对synchronized额外扩展了一些功能。</p>
<p>同时官方给出了使用样例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     lock.lock();  <span class="comment">// block until condition holds</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// ... method body</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS: lock.lock()；这句一定要放在try外面，<a href="https://www.zhihu.com/question/54613772" target="_blank" rel="noopener">点击这里详细查看</a></p>
<h5 id="ReetrantLock与synchronized有什么区别？两者相关的优缺点有哪些？"><a href="#ReetrantLock与synchronized有什么区别？两者相关的优缺点有哪些？" class="headerlink" title="ReetrantLock与synchronized有什么区别？两者相关的优缺点有哪些？"></a>ReetrantLock与synchronized有什么区别？两者相关的优缺点有哪些？</h5><ol>
<li><p><strong>底层实现</strong> synchronized 是<strong>JVM</strong>层面的锁，是<strong>Java关键字</strong>，ReetrantLock提供的<strong>API层面</strong>的锁。</p>
</li>
<li><p><strong>是否可手动释放 </strong>synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动让线程释放对锁的占用； ReentrantLock则需要用户去手动释放锁，如果没有手动释放锁，就可能导致死锁现象。所以比较synchronized更灵活。</p>
</li>
<li><p><strong>是否可中断 </strong>synchronized是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成； ReentrantLock则可以中断，可通过trylock(long timeout,TimeUnit unit)设置超时方法或者将lockInterruptibly()放到代码块中，调用interrupt方法进行中断。</p>
</li>
<li><p><strong>是否公平锁</strong> synchronized为非公平锁；ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空默认false非公平锁，true为公平锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">  &#x2F;&#x2F;此构造器提供了灵活的公平锁和非公平锁的使用选择</span><br><span class="line">    sync &#x3D; fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>锁是否可绑定条件Condition</strong> synchronized不能绑定； ReentrantLock通过绑定Condition结合await()/singal()方法实现线程的精确唤醒，而不是像synchronized通过Object类的wait()/notify()/notifyAll()方法要么随机唤醒一个线程要么唤醒全部线程</p>
</li>
<li><p><strong>作用目标</strong> synchronzied锁的是对象，锁是保存在对象头里面的，根据对象头数据来标识是否有线程获得锁/争抢锁；ReentrantLock锁的是线程，根据进入的线程和int类型的state标识锁的获得/争抢。</p>
</li>
</ol>
<p><a href="https://zhuanlan.zhihu.com/p/126085068" target="_blank" rel="noopener">点击这里详细查看</a></p>
<h4 id="ReetrantLock源码阅读分析"><a href="#ReetrantLock源码阅读分析" class="headerlink" title="ReetrantLock源码阅读分析"></a>ReetrantLock源码阅读分析</h4><h5 id="ReetrantLock的类图"><a href="#ReetrantLock的类图" class="headerlink" title="ReetrantLock的类图"></a>ReetrantLock的类图</h5><p><img src="../images/1591621164938.jpg" alt="1591621164938.jpg"></p>
<p>ReetrantLock中定义了一个内部类Sync继承AbstractQueueSynchronizer，然后由另外两个内部类FairSync,NonfairSync继承Sync来实现公平和非公平锁。</p>
<h5 id="ReetrantLock获取锁代码分析"><a href="#ReetrantLock获取锁代码分析" class="headerlink" title="ReetrantLock获取锁代码分析"></a>ReetrantLock获取锁代码分析</h5><p>先从ReetrantLock的构造方法来看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认构造器的是使用非公平锁</span></span><br><span class="line">      sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//此构造器提供了灵活的公平锁和非公平锁的使用选择</span></span><br><span class="line">      sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们已默认的非公平锁为例子来学习，在这之前，我们需要先梳理下AbstractQueueSynchronizer的相关内容。避免在ReetrantLock使用调用相关信息的时候一脸懵逼。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用state做标记位，用于判断资源是否满足</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">      state = newState;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>AbstractQueueSynchronizer使用state做标记位，用于判断资源是否被占有。所以这些变量都是使用volatile修饰的，就是为了在多线程的情况下保证线程可见。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示当前持有锁的线程</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">      exclusiveOwnerThread = thread;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Thread <span class="title">getExclusiveOwnerThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> exclusiveOwnerThread;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>AbstractQueueSynchronizer的父类AbstractOwnableSynchronizer中的属性exclusiveOwnerThread来存储当前已经占用资源的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//clh队列的头节点，事实上是一个哑巴节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="comment">//clh队列的尾巴节点，它指向队列中的最后一个节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AQS把等待线程封装成node构成了clh队列也就是所谓的sync queue 和 条件队列使用的是同一个Node对象</span></span><br><span class="line"><span class="comment">//只不过这边用prev、next实现双向链表，而条件队列使用的是nextWaiter属性，最终实现单向链表</span></span><br><span class="line"><span class="comment">//这么设计可以看出，node节点肯定存在从条件队列，转移到同步队列的转化操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  			<span class="comment">//表示共享模式</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">  			<span class="comment">//独占模式标示，在ReetrantLock的，此属性赋值为null</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">  			<span class="comment">//节点取消状态</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">  			<span class="comment">//节点的通知状体，该状态表明该节点释放资源后，会唤醒队列中的下一个阻塞线程</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">  			<span class="comment">//当前的等待状态</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">  </span><br><span class="line">  			<span class="comment">//当前节点的前置节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">  			<span class="comment">//当前节点的后置节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">  			<span class="comment">//保存当前节点的线程信息</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">  		</span><br><span class="line">        Node nextWaiter;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">            Node p = prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">            <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>AbstractQueueSynchronizer中的内部类把等待的线程封装成Node对象，用于构建双向的同步队列。</p>
<p>了解这些后我们从lock方法开始跟踪</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       sync.lock();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">               setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               acquire(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在调用默认非公平锁的lock方法中，上来先使用CAS判断一次state表示是否能抢占成功，成功则直接设置当前线程为占有资源的线程，否则进入acquire(1);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">         selfInterrupt();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在acquire()方法中，有4个方法我们来逐个分析</p>
<p>tryAcquire() 在非公平锁的实现代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">  				<span class="comment">//获取当前线程</span></span><br><span class="line">         <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">  				<span class="comment">//获取当前state的值</span></span><br><span class="line">         <span class="keyword">int</span> c = getState();</span><br><span class="line">         <span class="comment">//这里和非公平锁的入口代码一样先进行一轮获取锁的判断，获取成功后直接返回</span></span><br><span class="line">         <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                 setExclusiveOwnerThread(current);</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">  				<span class="comment">//开始校验当前线程是否占有资源的线程，如果是则进行重入</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">           <span class="comment">//计数加1</span></span><br><span class="line">             <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">             <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">       <span class="comment">//此处直接用setState修改状态也是线程安全的。因为上面的线程判断保证只有当前线程才能进入执行，所有不存在线程安全问题</span></span><br><span class="line">             setState(nextc);</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">  <span class="comment">//获取不到锁的话直接返回</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>如果抢占锁失败，按照tryAcquire返回的结果判断，会进入addWaiter(Node.EXCLUSIVE)方法，实际上这个Node.EXCLUSIVE为空的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//新建一个节点表示当前线程，模式为独占</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">  <span class="comment">//线开始进行快速入队</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//如果快速入队为执行失败，则进入自旋方法enq()进行处理</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//开始自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">     <span class="comment">// 如果tail为空，则进行初始化，此处是为了提高效率，用到才初始化。</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">          <span class="comment">//初始化head时是new了一个空Node。所有说明head只是一个哑巴节点。</span></span><br><span class="line">          <span class="comment">//head节点不代表任何线程，它就是一个空节点！！！</span></span><br><span class="line">          <span class="comment">//初始化完成后因为自旋会再此进行校验，此时会进入下面else分支</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//很明显，下面三句赋值语句不是一个原子操作</span></span><br><span class="line">            node.prev = t; <span class="comment">//这句可能会存在多个线程同时处理</span></span><br><span class="line">          <span class="comment">//但是通过下面的CAS,只会有一个线程设置尾节点成功，其他的线程则通过自旋再次进行判断，而此时</span></span><br><span class="line">          <span class="comment">// node.prev = t语句则会重先设置当前置节点为上一轮插入成功的尾节点</span></span><br><span class="line">          <span class="comment">//所以从后往前遍历能娶到最新的节点信息，而从前往后又有可能拿不到最后的节点的原因就是在这里</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以通过addWaiter()保证了Node节点被插入在队列的队尾。</p>
<p>结下来我们在看acquireQueued()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="comment">//获取节点的前置节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">          <span class="comment">//如果前置节点是head，说明排在第一（排除head），就再次尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">              <span class="comment">//此处setHead也是线程安全的，因为获取成功的线程才来执行</span></span><br><span class="line">              <span class="comment">//方法是把节点中的线程信息，和前置信息置空，新的哑巴节点，指向head</span></span><br><span class="line">              <span class="comment">//这么做的好处就无需再进行出队操作，直接把获取锁的node变成了head</span></span><br><span class="line">                setHead(node);</span><br><span class="line">              <span class="comment">// 旧的前置节点置空，通过gc回收就跟他说拜拜了</span></span><br><span class="line">                p.next = <span class="keyword">null</span>;</span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//校验节点是否可以挂起</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//这里是在可中断的锁的时候才会用到，处理再线程中断后的善后处理，这里不需要管</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再继续往下跟shouldParkAfterFailedAcquire(),这里就是通过当前节点的前置节点的waitStatus属性来判断是否挂起。先来回顾下，我们从上门addWaiter方法中可知，<strong>Node node = new Node(Thread.currentThread(), mode);</strong>每个节点只是初始化了一个普通Node对象，并没有设置waitStatus值。所以改等待状态的值默认是0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//首先获取前置节点的等待状态，</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">  <span class="comment">//如果是Node.SIGNAL，说明该节点执行结束会通知后继节点，所以当前节点以及是“设置好闹钟了”，可以直接挂起了</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">//重入锁的大于0的状态就是取消状态，下面循环往前找地状态不为取消的，直到找到一个不为取消状态的为止</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">      <span class="comment">//然后把当前节点挂在不为取消的后面，直接插队了</span></span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//否则给前置节点的状态设置为通知</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//很明显，这边返回表示线程还会执行上面acquireQueued方法中的for(;;)自旋一次。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在shouldParkAfterFailedAcquire校验可以挂起后，下面调用parkAndCheckInterrupt来挂起线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//线程最终在这个位置挂起，等待锁释放时后唤醒</span></span><br><span class="line">       LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">	<span class="comment">//这里为什么要返回一个线程的中断标记为呢？？？释放锁的时候再说哈哈</span></span><br><span class="line">       <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="ReetrantLock释放锁代码分析"><a href="#ReetrantLock释放锁代码分析" class="headerlink" title="ReetrantLock释放锁代码分析"></a>ReetrantLock释放锁代码分析</h5><p>我们从unlock方法开始分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这边直接就屌用AQS类中的release方法</span></span><br><span class="line">       sync.release(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到release中是有返回值的，核心就是tryRelease和unparkSuccessor两个方法我们来逐个分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">          Node h = head;</span><br><span class="line">          <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">              unparkSuccessor(h);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>tryrelease是在ReetrantLock中的内部类Sync实现的，为什么不放在子类failSync和nonFailSync中呢？因为不管是公平还是非公平锁，释放锁的是一样的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取标记为数值-1</span></span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">  <span class="comment">//不是持有锁的线程直接抛异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">//为什么没有多线程问题？因为所以释放锁的线程都是获得了锁的。</span></span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果tryRelease释放锁成功</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">         <span class="comment">//我们在这里！</span></span><br><span class="line">         <span class="comment">//我们在这里！</span></span><br><span class="line">           Node h = head;</span><br><span class="line">         <span class="comment">//获取头节点信息。为什么要校验h.waitStatus != 0</span></span><br><span class="line">         <span class="comment">//因为我们知道节点的状态只有三中，0 初始化，-1 通知，1 取消</span></span><br><span class="line">         <span class="comment">//h.waitStatus != 0 说明不是同步队列中最尾的节点。</span></span><br><span class="line">         <span class="comment">//因此不管是取消(虽然之前线程挂起会校验前置节点，跳过取消的节点，但释放的时候难免某些节点刚好取消了)还是通知都要去唤醒后继节点</span></span><br><span class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">               unparkSuccessor(h);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们在看unparkSuccessor唤醒后继节点的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;</span><br><span class="line">  <span class="comment">//如果后继节点状态是取消</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//这里去会沿着队列找一个状态不为取消的节点并且距离head节点最近</span></span><br><span class="line">      	<span class="comment">//且这为什么要从尾巴向前遍历呢？和上面分析的获取锁添加到等待队列的addWaiter()方法中的enq()方法使用的是一个思路</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">      <span class="comment">//如果找到，则唤醒线程 注意这里唤醒线程后是从哪里开始执行呢？</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在获取锁的时候我们知道，线程是在parkAndCheckInterrupt被挂起的，所以这边调用LockSupport.unpark()线程会被唤醒</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//线程从这里被唤醒</span></span><br><span class="line">       LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">//返回现场是否中断过的标志位</span></span><br><span class="line">       <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>因为是不响应线程中断的锁，所以不知道当前线程在等待的过程中是否被中断过，因此这边清除了线程的中断标志位并返回了是否中断的标志位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; </span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//我们在这里！这里之后还是自旋去获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">              <span class="comment">//设置标志位</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此如果线程曾经中断过，interrupted = true 会给出一个标志位到外边，再往外看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">       <span class="comment">//我们在这里</span></span><br><span class="line">         selfInterrupt();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里如果标记为是中断过则会调用selfInterrupt()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//最调用线程的的interrupt()</span></span><br><span class="line">  <span class="comment">//模拟刚才等待时的中断，骚不骚？     </span></span><br><span class="line">  Thread.currentThread().interrupt();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/05/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="squanche">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="squanche's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/05/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/" itemprop="url">并发与多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-05T14:32:05+08:00">
                2020-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h4><p>什么时<strong><em>并发（Concurrency）</em></strong>和<strong><em>并行（Parallelism）</em></strong></p>
<p>简单来说以 KTV 唱歌为例，并行指的是有多少人可以使用话筒同时唱歌，并发指的是同一个话筒被多个人轮流使用。</p>
<h5 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h5><p>是指在某个时间段内，多任务交替处理的能力。如同单核cpu要执行多个任务，cpu把执行时间切分成多个时间片用于不同的进程执行。由于cpu执行速度很快，所以对于用户来说，感觉是是同时多个进程同时在执行。</p>
<ol>
<li><p>并发挥序之间有互相制约的关系。 直接制约体现为一个程序需要另一个程序的计算结果，间接制约体现为多个程序竞争共享资源，如处理器、缓冲区等。</p>
</li>
<li><p>并发程序的执行过程是断断续续的。 程序需要记忆现场指令及执行点。</p>
</li>
<li><p>当并发数合理并且CPU拥有足够的处理能力句，并发会提高程序的运行效率。</p>
</li>
</ol>
<h5 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h5><p>并行是指同时处理多任务的能力。目前， CPU 已经发展为多核，可以同时执行多个互不依赖的指令及执行块。</p>
<h4 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h4><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体</p>
<h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5><p><strong>线程</strong>（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。</p>
<p>例如，楼下有一车砖头需要工人搬到 21 楼，如果 10 个人一起搬，速度 定比1个人搬要快，完成任务的总时间会极大减少。但是论单次的时间成本，由于楼梯交会等因素 10 个人比 个人要慢。如果无限地增加入数，比如10000 人参与搬砖时，反而会因为楼道拥墙不堪变得更慢，所以合适的人数才会使工作效率最大化。同理，合适的线程数才能让 CPU 资源被充分利用</p>
<p><img src="../images/image-20200605145830777.png" alt="image-20200605145830777"></p>
<h5 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h5><p>线程的生命周期有 <strong><em>NEW（新建状态）、RUNNABLE （就绪状态）、 RUNNING （运行状态）、</em></strong></p>
<p><strong><em>BLOCKED （阻塞状态）、 DEAD （终止状态）</em></strong>五种状态。</p>
<p>线程的状态流转图如下：</p>
<p><img src="../images/1591345506326.jpg" alt="1591345506326.jpg"></p>
<ol>
<li><strong><em>新建状态（New）</em></strong>：创建线程的方式有三种：第一种是继承自 Thread 类，第二种是实现 Runnable 接口，第三种是实现 Callable口。Callable和Runnable 两点不同，第一，可以通过call()获得返回值(可以通过futask.get()获取返回结果)。第二， call()可以抛出异常。</li>
</ol>
<p>（<strong><em>java本身是无法启动线程的，必须借助native方法如下start0()</em></strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is not invoked for the main method thread or "system"</span></span><br><span class="line"><span class="comment">     * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">     * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A zero status value corresponds to state "NEW".</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">     * so that it can be added to the group's list of threads</span></span><br><span class="line"><span class="comment">     * and the group's unstarted count can be decremented. */</span></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong><em>就绪状态（Runnable）</em></strong>：即就绪状态就是调用start()之后运行之前的状态。 线程的start()不能被多次调用，否则会抛出IllegalStateException异常。</li>
<li><p><strong><em>运行状态（RUNNING）</em></strong>：run()正在执行时线程的状态。 线程可能会由于某些因素而退出 RUNNING ，如时间、异常、锁、调度等。</p>
</li>
<li><p><strong><em>阻塞状态（BLOCKED）</em></strong>：有以下种情况。</p>
</li>
</ol>
<ul>
<li><p>同步阻塞锁被其他线程占用。</p>
</li>
<li><p>主动阻塞调用Thread的某些方法，主动让出 PU 执行权，比如 sleep()，join() 等。</p>
</li>
<li><p>等待阻塞执行了wait()。</p>
</li>
</ul>
<ol start="5">
<li><p><strong><em>即终止状态（DEAD ）</em></strong>：是 run() 执行结束，或同异常退出后的状态，此状态不可逆转。</p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><h5 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h5><ol>
<li>利用线程池管理并复用线程、控制最大并发数等。</li>
<li>实现任务线程队列缓存策略和拒绝机制。</li>
<li>实现某些与时间相关的功能，如定时执行、周期执行等。</li>
<li>隔离线程环境。比如，交易服务和搜索服务在同一台服务器上，分别开启两个线程池，交易线程的资源消耗明显要大；因此，通过配置独立的线程池将较慢的交易服务与搜索服务隔离开，避免各服务线程相互影响。<h5 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h5></li>
</ol>
</li>
</ol>
<p>先来看看构造方法的参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>corePoolSize</p>
<p> corePoolSize 表示常驻核心线程数。如果等于0 ，则任务执行完之后没有任何请求进入时销毁线程池的线程，如果大于0，即使本地任务执行完毕，核心线程也不会被销毁。这个值的设置非常关键，设置过大会浪费资源，设置过小会导致线程频繁地创建或销毁。</p>
</li>
<li><p>maximumPoolSize</p>
<p>maximumPoolSize 表示线程池能够容纳同时执行的最大线程数。必须大于或等于1。如果待执行的线程数大于此值，需要借助第5个参数的帮助，缓存在队列中。如果 maximumPoolSize和corePoolSize相等，即是固定大小线程池。</p>
</li>
<li><p>keepAliveTime</p>
<p>keepAliveTime表示线程池中的线程空闲时间，当空闲时间达keepAliveTime值时，线程会被销毁，直到只剩下corePoolSize个线程为止，避免浪费内存和旬柄资源。在默认情况下，当线程池的线程数大于corePoolSize 时，keepAliveTime才会起作 用。但是当ThreadPoolExecutor的allowCoreThreadTimeOut变量设置为 true 核心线程超时后也会被回收。</p>
</li>
<li><p>TimeUnit</p>
<p> TimeUnit表示时间单位。 keepAliveTime 的时间单位通常是TimeUnit.SECONDS</p>
</li>
<li><p>workQueue</p>
<p>workQueue表示缓存队列。当请求的线程数大于maximumPoolSize线程进入BlockingQueue 塞队列。后续示例代码申使用的 LinkedBlockingQueue 是单向链表，使用锁来控制入队和出队的原子性，两个锁分别控制元素的添加和获取，是一个生产消费模型队列。</p>
</li>
<li><p>threadFactory</p>
<p>threadFactory表示线程工厂。它用来生产一组相同任务的结程。线程池的命名是通过给这个 factory 增加组名前缀来实现的。在虚拟机枝分析时，就可以知道线程任务是由哪个线程工厂产生的。</p>
</li>
<li><p>handler</p>
<p>handler 表示执行拒绝策晤的对象。当超过第5个参数 workQueue的任务缓存区上限的时候，就可以通过该策略处理请求，这是种简单的限流保护。</p>
</li>
</ul>
<h5 id="jdk提供的几种线程池"><a href="#jdk提供的几种线程池" class="headerlink" title="jdk提供的几种线程池"></a>jdk提供的几种线程池</h5><p>在java.util.concurrent.Executors包下提供了4中线程池</p>
<ul>
<li><p>newCachedThreadPool</p>
<p>maximumPoolSize 最大可以至 Integer.MAX_VALUE, 是高度可伸缩的线程池 如果达到这个上限,相信没有任何服务器能够继续工作，肯定会抛出OOM异常。 keepAliveTime 默认为 60 秒，工作线程处于空闲状态则回收工作线程。如果任务数增加则再次创建出新线程处理任务。</p>
</li>
<li><p>newScheduledThreadPool</p>
<p>maximumPoolSize 最大可以至 Integer.MAX_VALUE，存在OOM风险</p>
</li>
<li><p>newSingleThreadExecutor</p>
<p>创建个单线程的线程池，相当于单线程串行执行所有任务 保证接任务的提交顺序依次执行。使用的LinkedBlockingQueue默认构造器，存在OOM风险。</p>
</li>
<li><p>newFixedThreadPool</p>
<p>输入的参数即是固定线程数，既是核心线程数也是最大线程数，不存在空闲线程，所以 keepAlieTime 等于0，同样使用的LinkedBlockingQueue是默认构造器，存在OOM风险。</p>
</li>
<li><p>newWorkStealingPool</p>
<p>JDK1.8引入，默认的并行度是cpu的核数。</p>
</li>
</ul>
<h5 id="jdk提供的拒绝策略"><a href="#jdk提供的拒绝策略" class="headerlink" title="jdk提供的拒绝策略"></a>jdk提供的拒绝策略</h5><p>自定义拒绝策略实现RejectedExecutionHandler接口的rejectedExecution方法即可。</p>
<ul>
<li>AbortPolicy（默认）丢弃并抛出RejectedExecutionHandler异常</li>
<li>DiscardPolicy 丢弃任务</li>
<li>DiscardOldestPolicy 丢弃队列中最早插入的任务</li>
<li>CallerRunsPolicy 直接执行任务的run方法</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/05/tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="squanche">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="squanche's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/05/tree/" itemprop="url">tree</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-05T11:43:20+08:00">
                2020-06-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><ol>
<li><p>如果某节点下方没有任何分叉的话，就是叶子节点。</p>
</li>
<li><p>从某节点出发，到叶子节点为止，最长简单路径上边的条数，称为该节点的<em>高度</em>。</p>
</li>
<li><p>从根节点出发，到某节点边的条数，称为该节点的深度</p>
</li>
</ol>
<h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5><ul>
<li><p>一个节点，即使只有根节点，也可以是一棵树。</p>
</li>
<li><p>其中任何一个节点与下面所有节点构成的树称为子。</p>
</li>
<li><p>根节点没有父节点，而叶子节点没有子节点子。</p>
</li>
<li><p>除根节点外，任何一个节点有且只有一个父节点</p>
</li>
<li><p>任何节点可以有0～n个子节点。</p>
</li>
</ul>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><h5 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h5><ol>
<li><p>树的左右高度差不能超过1</p>
</li>
<li><p>任何往下递归的左子树与右子树，必须符合第一条性质。</p>
</li>
<li><p>没有任何节点的空树或只有根节点的树也是平衡二叉树。  </p>
</li>
</ol>
<h5 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h5><p>平衡二叉树的左子树上所有节点的值都小于它，而它的右子树上所有节点的值都大于它。查找过程从树的根节点开始，沿着简单的判断向下走，小于节点值的往左边走，大于节点值的往右边走，直到找到目标数据或者到达叶子节点还未找到。</p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><h5 id="规则-2"><a href="#规则-2" class="headerlink" title="规则"></a>规则</h5><ol>
<li><p>节点只能是红色或黑色。</p>
</li>
<li><p>根节点必须是黑色。</p>
</li>
<li><p>所有 NIL 节点都是黑色的。即叶子节点下挂的两个虚节点。</p>
</li>
<li><p>一条路径上不能出现相连的两个红色节点。</p>
</li>
<li><p>在任何递归子树内，根节点到叶子节点的所有路径包含相同数目的黑色节点</p>
</li>
</ol>
<p>treeMap的是根据comparator或comparable来比较key的大小的。如果存在相等的key则暴力的替换掉。</p>
<p>所以treeMap的key必须实现comparable接口或者在treeMap的构造方法中提供comparator。同时treeMap的size是更具key的排序个数来统计的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/05/hashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="squanche">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="squanche's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/05/hashMap/" itemprop="url">hashMap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-05T11:42:49+08:00">
                2020-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>length</td>
<td>Table数组的长度</td>
</tr>
<tr>
<td>size</td>
<td>成功通过 put 方法添加到HashMap 中的所有元素的个数</td>
</tr>
<tr>
<td>hashCode</td>
<td>object.hashCode()返回的值，尽可能离散均匀分布</td>
</tr>
<tr>
<td>Hash</td>
<td>Object.HashCode()与当前集合的 table.Length(进行位运算的结果，以确定哈希糟位置</td>
</tr>
</tbody>
</table>
<p>Jdk1.7扩容的时候resize()使用的是<strong><em>头插法</em></strong></p>
<h5 id="hashMap对象丢失的原因有以下几点"><a href="#hashMap对象丢失的原因有以下几点" class="headerlink" title="hashMap对象丢失的原因有以下几点"></a>hashMap对象丢失的原因有以下几点</h5><ol>
<li><p>并发赋值时被覆盖</p>
</li>
<li><p>己遍历区间新增元素会丢失。</p>
</li>
<li><p>“新表”被覆盖。</p>
</li>
<li><p>迁移丢失。在迁移过程中,有并发时,next 被提前 null</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/05/%E9%9B%86%E5%90%88%E7%9A%84fast-fail%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="squanche">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="squanche's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/05/%E9%9B%86%E5%90%88%E7%9A%84fast-fail%E6%9C%BA%E5%88%B6/" itemprop="url">fast-fail</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-05T10:42:36+08:00">
                2020-06-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="fast-fail"><a href="#fast-fail" class="headerlink" title="fast-fail"></a>fast-fail</h2><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ol>
<li><p>java.util.collection的集合都是fast-fail机制，java.util.concurrent下的则是fast-safe机制</p>
</li>
<li><p>collection触发fast-fail的场景就是多线程情况下，当一个线程A正在遍历集合，另外一个线程B修改、删除、或者变更该集合中的元素，导致正在遍历的线程A抛出ConcurrentModificationException异常。</p>
</li>
<li><p>A线程在创建便利起iterator是会copy一份modCount的值给内部的变量expectedModCount，每次hasnext的时候去比较modCount的值和expectedModCount的值是否一致，不一致说明modCount++了，因为其他线程对该集合元素进行了操作。当前线程遍历则会报错</p>
</li>
</ol>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li>使用iterator加锁遍历</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator= list.iterator(); </span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123; </span><br><span class="line">sychonized（对象）｛</span><br><span class="line">String item= iterator.next(); </span><br><span class="line"><span class="keyword">if</span> （删除元素的条件） &#123; </span><br><span class="line">iterator.remove();&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用COW</li>
</ol>
<p>使用java.util.concurrent并发包下的<strong><em>copyOnWrite</em></strong>的集合。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">squanche</p>
              <p class="site-description motion-element" itemprop="description">选择比努力重要</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/squanche" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">squanche</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
